<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
        <meta id="metaThemeColor" name="theme-color" content="#667eea">
    <title>P2P Planning Poker</title>
    <script>
      (function() {
        try {
          const key = 'theme';
          const saved = localStorage.getItem(key);
          const pref = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
          const theme = saved === 'light' || saved === 'dark' ? saved : pref;
          document.documentElement.setAttribute('data-theme', theme);
          var meta = document.querySelector('meta[name="theme-color"]');
          if (meta) meta.setAttribute('content', theme === 'dark' ? '#0f1324' : '#667eea');
        } catch (e) {
          // no-op
        }
      })();
    </script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üÉè Planning Poker</h1>
            <button id="themeToggle" class="btn-inline theme-toggle" type="button" title="Toggle dark mode" aria-label="Toggle dark mode">üåô</button>
        </div>

        <div class="setup-screen active">
            <div class="setup-grid" role="group" aria-label="Room setup options">
                <section class="setup-card" aria-labelledby="createHeading">
                    <h2 id="createHeading" style="margin-bottom: 15px; font-size: 1.25rem;">Create a new room</h2>
                    <form id="createForm" novalidate>
                        <div class="input-group">
                            <label for="createName">Your name</label>
                            <input type="text" id="createName" name="createName" placeholder="Enter your name" autocomplete="name" required aria-describedby="createNameError" />
                            <div id="createNameError" class="field-error" aria-live="polite"></div>
                        </div>
                        <button type="submit" id="createRoomBtn">Create New Room</button>
                    </form>
                </section>

                <section class="setup-card" aria-labelledby="joinHeading">
                    <h2 id="joinHeading" style="margin-bottom: 15px; font-size: 1.25rem;">Join an existing room</h2>
                    <form id="joinForm" novalidate>
                        <div class="input-group">
                            <label for="joinName">Your name</label>
                            <input type="text" id="joinName" name="joinName" placeholder="Enter your name" autocomplete="name" required aria-describedby="joinNameError" />
                            <div id="joinNameError" class="field-error" aria-live="polite"></div>
                        </div>
                        <div class="input-group">
                            <label for="joinRoomId">Room ID</label>
                            <input type="text" id="joinRoomId" name="joinRoomId" placeholder="Enter room ID" required aria-describedby="joinRoomIdError" />
                            <div id="joinRoomIdError" class="field-error" aria-live="polite"></div>
                        </div>
                        <button type="submit" id="joinRoomBtn">Join Room</button>
                    </form>
                </section>
            </div>
        </div>

        <div class="game-screen">
            <div class="connection-status" id="connectionStatus">Connecting...</div>

            <div class="room-info">
                <strong>Room:</strong> <span id="currentRoom"></span> |
                <strong>You:</strong> <span id="currentPlayer"></span>
                <br>
                <small style="margin-top: 5px; display: block;">
                    Share this URL: <strong id="shareUrl"></strong>
                    <button id="copyUrlBtn" style="display: inline; width: auto; padding: 5px 10px; font-size: 12px;">üìã Copy</button>
                </small>
            </div>

            <h3 style="margin-bottom: 15px;">Players</h3>
            <div class="players" id="players"></div>

            <h3 style="margin-bottom: 15px;">Select Your Card</h3>
            <div class="cards-container" id="cards"></div>

            <div class="actions">
                <button id="revealBtn">Reveal Votes</button>
                <button id="resetBtn" class="secondary-btn">New Round</button>
            </div>

            <div class="results" id="results" style="display: none;"></div>
        </div>
    </div>

    <!-- Modal -->
    <div id="appModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalMessage">
        <div class="modal-dialog">
            <h3 id="modalTitle" class="modal-title">Notice</h3>
            <div id="modalMessage" class="modal-message"></div>
            <div class="modal-actions">
                <button id="modalCloseBtn" class="btn-inline" type="button">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { joinRoom as trysteroJoin } from 'https://cdn.jsdelivr.net/npm/trystero@0.22.0/+esm';

        const cardValues = ['0', '1', '2', '3', '5', '8', '13', '21', '?', '‚òï'];

        let room;
        let sendAction, getAction;
        let players = new Map();
        let myVote = null;
        let revealed = false;
        let myPeerId;
        let myPlayerName;
        const NAME_KEY = 'userName';

                // Theme toggle
                const THEME_KEY = 'theme';
                function getCurrentTheme() {
                    return document.documentElement.getAttribute('data-theme') || 'light';
                }
                function applyTheme(theme, persist = true) {
                    document.documentElement.setAttribute('data-theme', theme);
                    if (persist) {
                        try { localStorage.setItem(THEME_KEY, theme); } catch (e) {}
                    }
                    const meta = document.querySelector('meta[name="theme-color"]');
                    if (meta) meta.setAttribute('content', theme === 'dark' ? '#0f1324' : '#667eea');
                    const btn = document.getElementById('themeToggle');
                    if (btn) {
                        const toTheme = theme === 'dark' ? 'light' : 'dark';
                        btn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                        btn.title = `Switch to ${toTheme} mode`;
                        btn.setAttribute('aria-label', btn.title);
                    }
                }

        function generateRoomId() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function getRoomFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('room');
        }

        let lastFocusedEl = null;
        function openModal(message, variant = 'info', titleText) {
            const overlay = document.getElementById('appModal');
            const dialog = overlay?.querySelector('.modal-dialog');
            const title = document.getElementById('modalTitle');
            const msg = document.getElementById('modalMessage');
            const closeBtn = document.getElementById('modalCloseBtn');
            if (!overlay || !title || !msg || !closeBtn) return;

            // Variant styling
            overlay.classList.remove('modal-success', 'modal-error');
            if (variant === 'success') overlay.classList.add('modal-success');
            if (variant === 'error') overlay.classList.add('modal-error');

            // Content
            title.textContent = titleText || (variant === 'error' ? 'Error' : variant === 'success' ? 'Success' : 'Notice');
            msg.textContent = message || '';

            // Open + focus
            lastFocusedEl = document.activeElement;
            overlay.classList.add('open');
            // Move focus into dialog
            setTimeout(() => {
                closeBtn.focus();
            }, 0);

            // Basic focus trap within dialog
            function handleKeydown(e) {
                if (e.key === 'Escape') {
                    closeModal();
                } else if (e.key === 'Tab') {
                    const focusable = dialog.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    const list = Array.from(focusable).filter(el => !el.hasAttribute('disabled'));
                    if (list.length === 0) return;
                    const first = list[0];
                    const last = list[list.length - 1];
                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            }
            overlay.addEventListener('keydown', handleKeydown);
            overlay._handleKeydown = handleKeydown;
        }
        function closeModal() {
            const overlay = document.getElementById('appModal');
            if (!overlay) return;
            overlay.classList.remove('open');
            if (overlay._handleKeydown) {
                overlay.removeEventListener('keydown', overlay._handleKeydown);
                delete overlay._handleKeydown;
            }
            if (lastFocusedEl && typeof lastFocusedEl.focus === 'function') {
                lastFocusedEl.focus();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
                    // Initialize theme toggle UI
                    applyTheme(getCurrentTheme(), false);
                    const themeBtn = document.getElementById('themeToggle');
                    if (themeBtn) {
                        themeBtn.addEventListener('click', () => {
                            const next = getCurrentTheme() === 'dark' ? 'light' : 'dark';
                            applyTheme(next, true);
                        });
                    }
            const urlRoom = getRoomFromURL();
            if (urlRoom) {
                const joinRoomInput = document.getElementById('joinRoomId');
                if (joinRoomInput) joinRoomInput.value = urlRoom;
            }

            const createForm = document.getElementById('createForm');
            const joinForm = document.getElementById('joinForm');

            if (createForm) {
                createForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    createRoom();
                });
            }
            if (joinForm) {
                joinForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    joinRoom();
                });
            }

            // Clear error messages on input
            const createName = document.getElementById('createName');
            const joinName = document.getElementById('joinName');
            const joinRoomId = document.getElementById('joinRoomId');
            [createName, joinName, joinRoomId].forEach(input => {
                if (input) {
                    input.addEventListener('input', () => clearError(input));
                }
            });

            // Prefill name fields from previous session (localStorage)
            try {
                const storedName = localStorage.getItem(NAME_KEY);
                if (storedName) {
                    if (createName && !createName.value) createName.value = storedName;
                    if (joinName && !joinName.value) joinName.value = storedName;
                }
            } catch (e) {
                // ignore storage errors
            }

            // Keep stored name up-to-date as user types
            [createName, joinName].forEach(input => {
                if (!input) return;
                input.addEventListener('input', (ev) => {
                    const val = ev.target.value.trim();
                    try {
                        if (val) {
                            localStorage.setItem(NAME_KEY, val);
                        } else {
                            localStorage.removeItem(NAME_KEY);
                        }
                    } catch (e) {
                        // ignore storage errors
                    }
                });
            });

            // Modal close handlers
            const modalCloseBtn = document.getElementById('modalCloseBtn');
            const modalOverlay = document.getElementById('appModal');
            if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeModal);
            if (modalOverlay) {
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) closeModal();
                });
            }

            // Focus the first name field for accessibility
            if (createName) createName.focus();
        });

        function showError(inputEl, message) {
            if (!inputEl) return;
            const errorId = inputEl.getAttribute('aria-describedby');
            if (errorId) {
                const errorEl = document.getElementById(errorId);
                if (errorEl) errorEl.textContent = message || '';
            }
            if (message) inputEl.setAttribute('aria-invalid', 'true');
        }
        function clearError(inputEl) {
            if (!inputEl) return;
            const errorId = inputEl.getAttribute('aria-describedby');
            if (errorId) {
                const errorEl = document.getElementById(errorId);
                if (errorEl) errorEl.textContent = '';
            }
            inputEl.removeAttribute('aria-invalid');
        }

        function createRoom() {
            const nameInput = document.getElementById('createName');
            const playerName = nameInput ? nameInput.value.trim() : '';

            if (!playerName) {
                showError(nameInput, 'Please enter your name');
                nameInput && nameInput.focus();
                return;
            }

            clearError(nameInput);

            // Persist name for future visits
            try {
                localStorage.setItem(NAME_KEY, playerName);
            } catch (e) {
                // ignore storage errors
            }

            const roomId = generateRoomId();

            const url = new URL(window.location);
            url.searchParams.set('room', roomId);
            window.history.pushState({}, '', url);

            initGame(playerName, roomId);
        }

        function joinRoom() {
            const nameInput = document.getElementById('joinName');
            const roomInput = document.getElementById('joinRoomId');
            const playerName = nameInput ? nameInput.value.trim() : '';
            const roomId = roomInput ? roomInput.value.trim().toUpperCase() : '';

            let hasError = false;
            if (!playerName) {
                showError(nameInput, 'Please enter your name');
                if (!hasError) nameInput && nameInput.focus();
                hasError = true;
            } else {
                clearError(nameInput);
            }
            if (!roomId) {
                showError(roomInput, 'Please enter the room ID');
                if (!hasError) roomInput && roomInput.focus();
                hasError = true;
            } else {
                clearError(roomInput);
            }
            if (hasError) return;

            // Persist name for future visits
            try {
                localStorage.setItem(NAME_KEY, playerName);
            } catch (e) {
                // ignore storage errors
            }

            const url = new URL(window.location);
            url.searchParams.set('room', roomId);
            window.history.pushState({}, '', url);

            initGame(playerName, roomId);
        }

        function initGame(playerName, roomId) {
            myPlayerName = playerName;

            const config = {
                appId: 'planning-poker-p2p'
            };

            room = trysteroJoin(config, roomId);
            myPeerId = room.selfId;

            document.getElementById('currentRoom').textContent = roomId;
            document.getElementById('currentPlayer').textContent = playerName;

            const shareUrl = window.location.origin + window.location.pathname + '?room=' + roomId;
            document.getElementById('shareUrl').textContent = shareUrl;

            players.set(myPeerId, {
                id: myPeerId,
                name: playerName,
                vote: null,
                isMe: true
            });

            [sendAction, getAction] = room.makeAction('gameAction');

            getAction((data, peerId) => {
                console.log('=== ACTION RECEIVED ===');
                console.log('Type:', data.type);
                console.log('From peer:', peerId);
                console.log('Full data:', data);

                if (data.type === 'playerJoin') {
                    const incomingId = (data && data.player && data.player.id) ? data.player.id : peerId;
                    const incomingName = (data && data.player && data.player.name) ? data.player.name : 'Player';
                    const incomingVote = (data && data.player && typeof data.player.vote !== 'undefined') ? data.player.vote : null;

                    console.log('Resolved playerJoin -> id:', incomingId, 'name:', incomingName, 'from peer:', peerId);

                    if (incomingId === myPeerId) {
                        console.log('Skipped - this is me');
                    } else {
                        players.set(incomingId, {
                            id: incomingId,
                            name: incomingName,
                            vote: incomingVote,
                            isMe: false
                        });
                        console.log('Player added! Total players:', players.size);
                        renderPlayers();
                        updateConnectionStatus();
                    }
                } else if (data.type === 'vote') {
                    if (players.has(peerId)) {
                        players.get(peerId).vote = data.vote;
                        console.log('Player', peerId, 'voted:', data.vote);
                        renderPlayers();
                    }
                } else if (data.type === 'reveal') {
                    revealed = true;
                    renderPlayers();
                    showResults();
                } else if (data.type === 'reset') {
                    revealed = false;
                    players.forEach(p => p.vote = null);
                    myVote = null;
                    document.getElementById('results').style.display = 'none';
                    renderPlayers();
                    renderCards();
                }
            });

            room.onPeerJoin(peerId => {
                console.log('Peer joined:', peerId);
                updateConnectionStatus();

                const myInfo = {
                    type: 'playerJoin',
                    player: {
                        id: myPeerId,
                        name: myPlayerName,
                        vote: myVote
                    }
                };
                console.log('Sending my info:', myInfo);

                setTimeout(() => {
                    sendAction(myInfo);
                }, 300);
            });

            room.onPeerLeave(peerId => {
                console.log('Peer left:', peerId);
                players.delete(peerId);
                renderPlayers();
                updateConnectionStatus();
            });

            document.querySelector('.setup-screen').classList.remove('active');
            document.querySelector('.game-screen').classList.add('active');

            renderCards();
            renderPlayers();
            updateConnectionStatus();

            document.getElementById('revealBtn').addEventListener('click', revealVotes);
            document.getElementById('resetBtn').addEventListener('click', resetVotes);
            document.getElementById('copyUrlBtn').addEventListener('click', copyUrl);
        }

        function renderCards() {
            const container = document.getElementById('cards');
            container.innerHTML = '';

            cardValues.forEach(value => {
                const card = document.createElement('div');
                card.className = 'card';
                if (myVote === value) card.classList.add('selected');
                card.textContent = value;
                card.onclick = () => selectCard(value);
                container.appendChild(card);
            });
        }

        function selectCard(value) {
            myVote = value;
            players.get(myPeerId).vote = value;

            sendAction({
                type: 'vote',
                vote: value
            });

            renderCards();
            renderPlayers();
        }

        function renderPlayers() {
            const container = document.getElementById('players');
            container.innerHTML = '';

            players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';

                if (player.vote !== null) card.classList.add('voted');
                if (player.isMe) card.classList.add('me');

                const name = document.createElement('div');
                name.className = 'player-name';
                name.textContent = player.name + (player.isMe ? ' (You)' : '');

                const status = document.createElement('div');
                status.className = 'player-status';
                status.textContent = player.vote !== null ? '‚úì Voted' : 'Waiting...';

                card.appendChild(name);
                card.appendChild(status);

                if (revealed && player.vote !== null) {
                    const vote = document.createElement('div');
                    vote.className = 'player-vote';
                    vote.textContent = player.vote;
                    card.appendChild(vote);
                }

                container.appendChild(card);
            });
        }

        function revealVotes() {
            revealed = true;
            sendAction({ type: 'reveal' });
            renderPlayers();
            showResults();
        }

        function resetVotes() {
            revealed = false;
            players.forEach(p => p.vote = null);
            myVote = null;

            sendAction({ type: 'reset' });

            document.getElementById('results').style.display = 'none';
            renderPlayers();
            renderCards();
        }

        function showResults() {
            const votes = Array.from(players.values())
                .map(p => p.vote)
                .filter(v => v !== null && v !== '?' && v !== '‚òï');

            if (votes.length === 0) return;

            const numericVotes = votes.map(v => parseFloat(v)).filter(v => !isNaN(v));

            if (numericVotes.length === 0) {
                document.getElementById('results').innerHTML = '<h3>No numeric votes to analyze</h3>';
                document.getElementById('results').style.display = 'block';
                return;
            }

            const sum = numericVotes.reduce((a, b) => a + b, 0);
            const avg = sum / numericVotes.length;
            const min = Math.min(...numericVotes);
            const max = Math.max(...numericVotes);

            const resultsHtml = `
                <h3>Results</h3>
                <div class="result-stats">
                    <div class="stat">
                        <div class="stat-value">${avg.toFixed(1)}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${min}</div>
                        <div class="stat-label">Minimum</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${max}</div>
                        <div class="stat-label">Maximum</div>
                    </div>
                </div>
            `;

            document.getElementById('results').innerHTML = resultsHtml;
            document.getElementById('results').style.display = 'block';
        }

        function copyUrl() {
            const url = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(url).then(() => {
                openModal('URL copied to clipboard! Share it with your team.', 'success', 'Copied');
            }).catch(() => {
                openModal('Failed to copy URL. Please copy it manually.', 'error', 'Copy failed');
            });
        }

        function updateConnectionStatus() {
            const status = document.getElementById('connectionStatus');
            if (players.size > 1) {
                status.textContent = `‚úì Connected with ${players.size - 1} player(s)`;
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'Waiting for players to join...';
                status.className = 'connection-status';
            }
        }

        window.gameApp = {
            createRoom,
            joinRoom,
            revealVotes,
            resetVotes,
            copyUrl
        };
    </script>
</body>
</html>
